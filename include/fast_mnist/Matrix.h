#ifndef MATRIX_H
#define MATRIX_H

/** \file matrix.h A 2-D matrix class.  This file contains the
    declaration for a simple 2-D matrix class along with several
    convenience operators to streamline its use.

*/

#include <cassert>
#include <cstddef>
#include <iosfwd>
#include <vector>

/** Shortcut for the value of each element in the matrix */
using Val = double;

/** A matrix class to perform basic matrix operations.

    The class essentially encapsulates a 2-d matrix of double values
    and performs the following matrix operations:

    <ul>
    <li>Create a matrix of given dimensions.</li>

    <li>Matrix multiplication using Block matrix multiplication.</li>

    <li> Stream insertion and extraction operators to conveniently
    load and print values.</li>

    </ul>
*/
class Matrix {
    /** Stream insertion operator to ease printing matrices
     *
     * This method prints the dimension of the matrix and then prints
     * the values in a row-by-row manner.  The output is setup to be
     * consistent with the stream extraction operator.
     *
     * \param[out] os The output stream to where the data is to be
     * written. This could be any output stream -- for example,
     * a std::ofstream, std::ostringstream, or std::cout.
     *
     * \param[in] matrix The matrix to be written.
     *
     * \return As per convention, this method returns the supplied
     * output stream.
     */
    friend std::ostream& operator<<(std::ostream& os, const Matrix& matrix);

    /** Stream extraction operator to ease reading matrices
     *
     * This method reads the dimension of the matrix and then reads
     * the values in a row-by-row manner.  The input is assumed to be
     * that one generated by the stream insertion operator.
     *
     * \param[in/out] in The input stream to where the data is to be
     * read. This could be any input stream -- for example,
     * a std::ifstream, std::istringstream, or std::cin.
     *
     * \param[in] matrix The matrix to be read.
     *
     * \return As per convention, this method returns the supplied
     * input stream.
     */
    friend std::istream& operator>>(std::istream& is, Matrix& matrix);

  public:
    /** Perform the in-place AXPY operation on this matrix.
     *
     * Computes *this += alpha * X for matrices of identical
     * shape. This method assumes both matrices are conformable and
     * uses contiguous row-major traversal with the matrix-specific
     * leading dimension to preserve alignment and performance.
     *
     * \param[in] alpha The scalar multiplier for matrix X.
     * \param[in] X The addend matrix, which must have the same
     *              dimensions as this matrix.
     */
    void axpy(Val alpha, const Matrix& X);

    /** Tag type to request construction without initializing elements.
     *
     * Passing this tag to a constructor creates storage for the matrix
     * without writing any values to it. This avoids unnecessary
     * initialization work on hot paths where values will be
     * immediately overwritten.
     */
    struct NoInit {};

    /**
     * Constructor to create and initialize a matrix.
     *
     * \param[in] rows The number of rows to be created in the
     * matrix.
     *
     * \param[in] cols The number of cols to be created in the matrix.
     *
     * \param[in] initVal The inital value to be set for each entry in
     * the matrix.
     */
    explicit Matrix(const size_t rows = 0, const size_t cols = 0,
                    const Val initVal = 0);

    /** Construct a matrix of given size without initializing elements.
     *
     * \param[in] rows Number of rows.
     * \param[in] cols Number of columns.
     * \param[in] NoInit Tag to select the no-initialization overload.
     */
    Matrix(size_t rows, size_t cols, NoInit);

    /**
     * Returns the height or number of rows in this matrix.
     *
     * \return Returns the height or number of rows in this matrix.
     */
    std::size_t height() const {
        return rows_;
    }

    /**
     * Returns the width or number of columns in this matrix.
     *
     * \return Returns the width or number of columns in this matrix.
     */
    std::size_t width() const {
        return cols_;
    }

    /** Returns true if this matrix has no elements. */
    bool empty() const {
        return (rows_ == 0 || cols_ == 0);
    }

    /**
     * Creates a new matrix in which each value is obtained by
     * applying a given unary operator to each entry in the matrix.
     *
     * \param[in] operation The unary operation to be used to create
     * the given matrix.
     */
    template <typename UnaryOp> Matrix apply(const UnaryOp& operation) const {
        if (empty()) {
            return *this;
        }
        Matrix result(rows_, cols_, NoInit{});
        for (std::size_t r = 0; r < rows_; ++r) {
            const Val* src = data_ + r * ld_;
            Val* dst = result.data_ + r * result.ld_;
            for (std::size_t c = 0; c < cols_; ++c) {
                dst[c] = operation(src[c]);
            }
        }
        return result;
    }

    /**
     * Creates a new matrix in which each value is obtained by
     * applying a given binary operator to each entry in this matrix
     * and another matrix.
     *
     * \param[in] other The other matrix to be used. Note that the
     * other matrix must be exactly the same dimension of this this.
     * Otherwise, this method throws an exception.
     *
     * \param[in] operation The binary operation to be used to create
     * each value in the given matrix.
     */
    template <typename BinaryOp>
    Matrix apply(const Matrix& other, const BinaryOp& operation) const {
        assert(height() == other.height() && width() == other.width());
        if (empty()) {
            return *this;
        }
        Matrix result(rows_, cols_, NoInit{});
        for (std::size_t r = 0; r < rows_; ++r) {
            const Val* a = data_ + r * ld_;
            const Val* b = other.data_ + r * other.ld_;
            Val* c = result.data_ + r * result.ld_;
            for (std::size_t col = 0; col < cols_; ++col) {
                c[col] = operation(a[col], b[col]);
            }
        }
        return result;
    }

    /**
     * Operator to add two matrices with the same dimensions together.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by adding the corresponding values from \c this and
     * rhs.
     */
    Matrix operator+(const Matrix& rhs) const {
        return apply(rhs,
                     [](const auto& v1, const auto& v2) { return v1 + v2; });
    }

    /**
     * Operator for computing the Hadamard product of two matrices
     * with the same dimensions.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by multiplying the corresponding values from \c this
     * and rhs.
     */
    Matrix operator*(const Matrix& rhs) const {
        return apply(rhs,
                     [](const auto& v1, const auto& v2) { return v1 * v2; });
    }

    /**
     * Operator for computing the Hadamard product of two matrices
     * with the same dimensions.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by multiplying the corresponding values from \c this
     * and rhs.
     */
    Matrix operator*(const Val val) const {
        return apply([val](const auto& v) { return v * val; });
    }

    /**
     * Operator to subtract two matrices with the same dimensions.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same dimension as this matrix.  Otherwise this method
     * throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by subtracting the corresponding values from \c this
     * and rhs.
     */
    Matrix operator-(const Matrix& rhs) const {
        return apply(rhs,
                     [](const auto& v1, const auto& v2) { return v1 - v2; });
    }

    /**
     * Performs the dot product of two matrices. This method has a
     * O(n^3) time complexity.
     *
     * \param[in] rhs The other matrix to be used.  This matrix must
     * have the same number of rows as the number of columns in this
     * matrix.  Otherwise this method throws an excpetion.
     *
     * \return The resulting matrix in which each value has been
     * computed by multiplying the corresponding values from \c this
     * and rhs.
     */
    Matrix dot(const Matrix& rhs) const;

    /**
     * Returns the transpose of this matrix.
     */
    Matrix transpose() const;

    struct Row {
        Val* p;
        std::size_t n;
        inline Val& operator[](std::size_t c) noexcept {
            return p[c];
        }
        inline const Val& operator[](std::size_t c) const noexcept {
            return p[c];
        }
        inline Val* data() noexcept {
            return p;
        }
        inline const Val* data() const noexcept {
            return p;
        }
        inline std::size_t size() const noexcept {
            return n;
        }
        inline Val* begin() noexcept {
            return p;
        }
        inline Val* end() noexcept {
            return p + n;
        }
        inline const Val* begin() const noexcept {
            return p;
        }
        inline const Val* end() const noexcept {
            return p + n;
        }
        operator std::vector<Val>() const {
            return std::vector<Val>(p, p + n);
        }
    };

    struct CRow {
        const Val* p;
        std::size_t n;
        inline const Val& operator[](std::size_t c) const noexcept {
            return p[c];
        }
        inline const Val* data() const noexcept {
            return p;
        }
        inline std::size_t size() const noexcept {
            return n;
        }
        inline const Val* begin() const noexcept {
            return p;
        }
        inline const Val* end() const noexcept {
            return p + n;
        }
        operator std::vector<Val>() const {
            return std::vector<Val>(p, p + n);
        }
    };

    /**
     * Returns a row of the matrix as a Row object.
     *
     * \param[in] r The row index to be returned.
     * \return A Row object representing the specified row.
     */
    inline Row operator[](std::size_t r) noexcept {
        return Row{data_ + r * ld_, cols_};
    }

    /**
     * Returns a row of the matrix as a CRow object.
     *
     * \param[in] r The row index to be returned.
     * \return A CRow object representing the specified row.
     */
    inline CRow operator[](std::size_t r) const noexcept {
        return CRow{data_ + r * ld_, cols_};
    }

  private:
    /**
     * The number of rows, columns, and leading dimension of the matrix.
     */
    std::size_t rows_{0}, cols_{0}, ld_{0};

    /**
     * The data of the matrix, stored as a contiguous array.
     */
    Val* data_{nullptr};

    /**
     * Allocates memory for the matrix.
     */
    void allocate();

    /**
     * Deallocates memory for the matrix.
     */
    void deallocate();

  public:
    /**
     * Copy constructor to preserve value semantics.
     *
     * \param[in] other The other matrix to be copied.
     * \return A new matrix with the same values as the other matrix.
     */
    Matrix(const Matrix& other);

    /**
     * Move constructor to preserve value semantics.
     *
     * \param[in] other The other matrix to be moved.
     * \return A new matrix with the same values as the other matrix.
     */
    Matrix(Matrix&& other) noexcept;

    /**
     * Copy assignment operator to preserve value semantics.
     *
     * \param[in] other The other matrix to be copied.
     * \return A new matrix with the same values as the other matrix.
     */
    Matrix& operator=(const Matrix& other);

    /**
     * Move assignment operator to preserve value semantics.
     *
     * \param[in] other The other matrix to be moved.
     * \return A new matrix with the same values as the other matrix.
     */
    Matrix& operator=(Matrix&& other) noexcept;

    /**
     * Destructor to release the memory of the matrix.
     */
    ~Matrix();
};

#endif
